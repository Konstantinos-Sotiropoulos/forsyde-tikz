% A simple library for signal flow diagrams
% based on the pgf/tikz package of Till Tantau
%
% Author: Dr. Karlheinz Ochs, Ruhr-University of Bochum, Germany
% Version: 0.1
% Date: 2007/01/05
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{pgfplots}
\RequirePackage{pgfkeys}
\RequirePackage{xparse}
\RequirePackage{todonotes} % WHA?!
\RequirePackage{ezkeys}
\usetikzlibrary{decorations.markings, shapes, calc, fit, backgrounds}

\ProvidesPackage{forsyde-tikz}
              [2014/12/01 v0.1 ForSyDe TikZ Library]

%
% Libraries for signal flow diagrams.
%
\usetikzlibrary{fsignals,fshapes,}


%%%%%%%%%%%%%
% CONSTANTS %
%%%%%%%%%%%%%
% Colors
\newcommand{\defaultdrawcolor}{black}     		% draw color of signal paths
\newcommand{\defaultfillcolor}{white}     		% draw color of signal paths
\definecolor{sycolor}{RGB}{148,183,215}
\definecolor{ctcolor}{RGB}{225,119,19}
\definecolor{decolor}{RGB}{80,229,154}
\definecolor{sdfcolor}{RGB}{220,220,20}
\definecolor{blackboxcolor}{gray}{0.80}
% line widths of
\newlength{\sepq}
\pgfmathsetlength{\sepq}{2pt}                % constant for small inter-node separation (used for example in function nodes)
\newcommand{\compositelinewidth}{.4pt}       % composite process line width
\newcommand{\skeletonlinewidth}{1pt}         % parallel processes line width
\newcommand{\signalpathlinewidth}{1pt}       % signal paths
\newcommand{\functionpathlinewidth}{.8pt}    % function paths
\newcommand{\vectorpathlinewidth}{4pt}       % vector paths
% sizes, etc.
\newcommand{\tokensize}{3.5pt}
\newcommand{\halftokensize}{1.75pt}
\newcommand{\vectorportsize}{3pt}
\newcommand{\signalportsize}{2pt}

%%%%%%%%%%%%%%%%%%%%%%%%
% GENERIC TIKZ HELPERS %
%%%%%%%%%%%%%%%%%%%%%%%%
% Positioning of node text.
% #1 = node label
% #2 = label text
\newcommand{\textaboveof}[2]{\pgftext[bottom,at=\pgfpointanchor{#1}{north},y=+1mm]{#2}}%
\newcommand{\textrightof}[2]{\pgftext[left,  at=\pgfpointanchor{#1}{east}, x=+1mm]{#2}}%
\newcommand{\textbelowof}[2]{\pgftext[top,   at=\pgfpointanchor{#1}{south},y=-1mm]{#2}}%
\newcommand{\textleftof} [2]{\pgftext[right, at=\pgfpointanchor{#1}{west}, x=-1mm]{#2}}%

\makeatletter
\newcounter{r}
\newcommand{\tikzgrid}{%
  \pgfsetxvec{\pgfpoint{\tikz@node@distance}{0mm}}%
  \pgfsetyvec{\pgfpoint{0mm}{\tikz@node@distance}}%
  \tikz@matrix%
}
\newcommand{\tikz@matrix}[1]{\tikz@@matrix#1@}%
\def\tikz@@matrix#1@{\do@rows#1\\@\\}%
\def\do@rows#1\\{%
  \ifx#1@%
  \else%
    \setcounter{r}{0}%
    \do@columns#1&@&%
    \pgftransformshift{\pgfpointxy{-\ther}{-1}}%
    \expandafter\do@rows%
  \fi}%
\def\do@columns#1&{%
  \if#1@%
  \else%
    \stepcounter{r}%
    \pgftransformshift{\pgfpointxy{1}{0}}%
    #1;%
    \expandafter\do@columns%
  \fi}%
\makeatother

%%%%%%%%%%%%%%%%
% ENVIRONMENTS %
%%%%%%%%%%%%%%%%
\newif\ifnolabel
\newif\ifnocolor
\pgfkeys{
	/tikz/nomoccolor/.is if=nocolor,
	/tikz/nomoclabel/.is if=nolabel,
	/tikz/type style/.store in = \typeStyle,
	/tikz/type style = \scriptsize\textit,
	/tikz/label style/.store in = \labelStyle,
	/tikz/label style = \textbf,
	/tikz/function style/.store in = \funcStyle,
	/tikz/function style = \scriptsize,
	/tikz/moc/.store in = \MoC,
	/tikz/moc = none,
	/tikz/mocin/.store in = \MoCin,
	/tikz/mocin = none,
	/tikz/mocout/.store in = \MoCout,
	/tikz/mocout = none,
}
\newcommand{\getmoclabel}[1]{\ifthenelse{\equal{#1}{sy}}{SY}{\ifthenelse{\equal{#1}{de}}{DE}{\ifthenelse{\equal{#1}{ct}}{CT}{\ifthenelse{\equal{#1}{sdf}}{SDF}{}}}}}

%%%%%%%%%%%%%%%%%
% GENERIC NODES %
%%%%%%%%%%%%%%%%%

% Applicative
\pgfkeys{
	/applicative/.is family, /applicative,
	default/.style = {moc=none, reverse = false, type= , ni=1, no=1, nf=0, f1=$ f_1 $, f2=$ f_2 $, f3=$ f_3 $, f4=$ f_4 $, line sep=0pt},
 	moc/.estore in = \pMoc,
 	type/.estore in = \pType,
	ni/.estore in = \pNIn,
	no/.estore in = \pNOut,
	nf/.estore in = \pNFunc,
	f1/.estore in = \pFuncA,
	f2/.estore in = \pFuncB,
	f3/.estore in = \pFuncC,
	f4/.estore in = \pFuncD,
	line sep/.estore in = \pLineSep,
	reverse/.is toggle,
}
% Generic applicative leaf process
% #1 = environment keys
% #2 = node name
% #3 = node position
% #4 = node label
\newcommand{\applicative}[4][]{
	\pgfkeys{/applicative, default, #1}%
	\node[inner sep=0pt] (#2_label) at (#3) {\labelStyle{#4}};
	\node[func\pNFunc, font=\funcStyle, yshift=2\sepq+\pLineSep, anchor=south] (f#2) at (#2_label.north) {
		\ifnum \pNFunc>0 \nodepart{fa} \pFuncA\else\fi
		\ifnum \pNFunc>1 \nodepart{fb} \pFuncB\else\fi
		\ifnum \pNFunc>2 \nodepart{fc} \pFuncC\else\fi
		\ifnum \pNFunc>3 \nodepart{fd} \pFuncD\else\fi
	};
	\node[anchor=north, yshift=-\pLineSep] (#2_type) at (#2_label.south) {\typeStyle{\pType\ifnolabel\else\getmoclabel{\pMoc}\fi}};
	\iftoggle{/applicative/reverse}
		{\node[i\pNIn o\pNOut, rotate=180, inner sep=0pt, fit=(f#2)(#2_label)(#2_type),] (#2) {};}
		{\node[i\pNIn o\pNOut, inner sep=0pt, fit=(f#2)(#2_label)(#2_type),] (#2) {};}
	\begin{pgfonlayer}{background}
		\node[applshape, draw, moc=\pMoc, inner sep=0pt, fit=(f#2)(#2_label)(#2_type)] {};
	\end{pgfonlayer}
}

% Primitive 
\pgfkeys{
	/primitive/.is family, /primitive,
	default/.style = {moc=none, reverse = false, type= , ni=1, no=1,},
 	moc/.estore in = \pMoc,
 	type/.estore in = \pType,
	ni/.estore in = \pNIn,
	no/.estore in = \pNOut,
	reverse shape/.is toggle,
	reverse/.is toggle,
}
% Generic primite box-shaped leaf process
% #1 = environment keys
% #2 = node name
% #3 = node position
% #4 = node label
\newcommand{\primitivebox}[4][]{
	\applicative[#1, nf=0, line sep=-2pt]{#2}{#3}{#4}
}
% Generic primite special-shaped leaf process
% #1 = environment keys
% #2 = node name
% #3 = node position
\newcommand{\primitivespecial}[3][]{
	\pgfkeys{/primitive, default, #1}%
	\pgfmathsetlength{\foo}{max(\pNIn,\pNOut)*5pt}
	\iftoggle{/primitive/reverse shape}
		{\node[\pType, draw, moc=\pMoc, inner sep=\foo, rotate=180,] (#2_shape) at (#3) {};}	
		{\node[\pType, draw, moc=\pMoc, inner sep=\foo,] (#2_shape) at (#3) {};}	
	\iftoggle{/primitive/reverse}
		{\node[i\pNIn o\pNOut, rotate=180, inner sep=0pt, fit=(#2_shape),] (#2) {};}
		{\node[i\pNIn o\pNOut, inner sep=0pt, fit=(#2_shape),] (#2) {};}
}

% Interface
\pgfkeys{
	/interface/.is family, /interface,
	default/.style = {mocin = none, mocout = none, },
 	mocin/.estore in = \pMocIn,
 	mocout/.estore in = \pMocOut,
	reverse/.is toggle,
}
\newcommand{\interface}[3][]{
	\pgfkeys{/interface, default, #1}%
	\iftoggle{/interface/reverse}{
		\node[domaininterfacerev, mocin=\pMocIn, mocout=\pMocOut, minimum width=30pt, minimum height=30pt, draw] (#2_shape) at (#3) {
			\nodepart{mocin} \typeStyle{\ifnolabel\else\getmoclabel{\pMocIn}\fi}
			\nodepart{mocout} \typeStyle{\ifnolabel\else\getmoclabel{\pMocOut}\fi} 
		};
		\node[i1o1, rotate=180, inner sep=0pt, fit=(#2_shape),] (#2) {};
	}{
		\node[domaininterface, mocin=\pMocIn, mocout=\pMocOut, minimum width=30pt, minimum height=30pt, draw] (#2_shape) at (#3) {
			\nodepart{mocin} \typeStyle{\ifnolabel\else\getmoclabel{\pMocIn}\fi}
			\nodepart{mocout} \typeStyle{\ifnolabel\else\getmoclabel{\pMocOut}\fi} 
		};
		\node[i1o1, inner sep=0pt, fit=(#2_shape),] (#2) {};
	}	
}

%Composite
\pgfkeys{
	/composite/.is family, /composite,
	default/.style = {ni=0, no=0 ,inner sep = 15pt},
 	inner sep/.estore in = \innerSep,
	ni/.estore in = \pNIn,
	no/.estore in = \pNOut,
	reverse/.is toggle,
}
% Generic composite process
% #1 = environment keys
% #2 = node name
% #3 = list of nodes clustered
% #4 = node label
\newcommand\composite[4][]{
	\pgfkeys{/composite, default, #1}%
	\node[composite, inner sep=\innerSep, fit=#3 , draw] (#2_shape) {};
	\node[anchor=south east] (#2_label) at (#2_shape.south east) {\footnotesize\labelStyle{#4}}; 
	\iftoggle{/composite/reverse}
		{\node[i\pNIn o\pNOut, rotate=180, inner sep=0pt, fit=(#2_shape),] (#2) {};}
		{\node[i\pNIn o\pNOut, inner sep=0pt, fit=(#2_shape),] (#2) {};}
}
% Generic black-box composite process
% #1 = environment keys
% #2 = node name
% #3 = node position
% #4 = node label
\newcommand\compositebbox[4][]{
	\pgfkeys{/composite, default, #1}%
	\node[rectangle, rounded corners = 3pt, minimum width=30pt, minimum height=30pt, inner sep=\innerSep,
		draw=\defaultdrawcolor, fill=blackboxcolor] (#2_shape) at (#3) {\labelStyle{#4}};
	\iftoggle{/composite/reverse}
		{\node[i\pNIn o\pNOut, rotate=180, inner sep=0pt, fit=(#2_shape),] (#2) {};}
		{\node[i\pNIn o\pNOut, inner sep=0pt, fit=(#2_shape),] (#2) {};}
}

%Parallel computation
\pgfkeys{%
	/parcomp/.is family, /parcomp,
	default/.style = {reverse = false, type=genericpar , ni=1, no=1, nf=0, f1=$ \langle f_1\rangle $, f2=$ \langle f_2\rangle $, f3=$ \langle f_3\rangle $, f4=$ \langle f_4\rangle $, inner sep=18pt},
 	type/.estore in = \pType,
	ni/.estore in = \pNIn,
	no/.estore in = \pNOut,
	nf/.estore in = \pNFunc,
	f1/.estore in = \pFuncA,
	f2/.estore in = \pFuncB,
	f3/.estore in = \pFuncC,
	f4/.estore in = \pFuncD,
	inner sep/.estore in = \innerSep,
	reverse/.is toggle,
}
% #1 = environment keys
% #2 = node name
% #3 = list of nodes clustered
% #4 = node label
\newcommand\parcomp[4][]{
	\pgfkeys{/parcomp, default, #1}%
	\iftoggle{/parcomp/reverse}{
		\node[\pType, draw, inner sep=\innerSep, fit=#3, rotate=180,] (#2_shape) {};
		\node[i\pNIn o\pNOut, rotate=180, inner sep=0pt, fit=(#2_shape),] (#2) {};
		\node[anchor=south east] (#2_label) at (#2_shape.north west) {\footnotesize\labelStyle{#4}}; 
		\node[func\pNFunc, font=\funcStyle, anchor=south west] (f#2) at (#2_shape.south east) {
			\ifnum \pNFunc>0 \nodepart{fa} \pFuncA\else\fi
			\ifnum \pNFunc>1 \nodepart{fb} \pFuncB\else\fi
			\ifnum \pNFunc>2 \nodepart{fc} \pFuncC\else\fi
			\ifnum \pNFunc>3 \nodepart{fd} \pFuncD\else\fi
		};
	}{
		\node[\pType, inner sep=\innerSep, fit=#3, draw] (#2_shape) {};
		\node[i\pNIn o\pNOut, inner sep=0pt, fit=(#2_shape),] (#2) {};
		\node[anchor=south east] (#2_label) at (#2_shape.south east) {\footnotesize\labelStyle{#4}}; 
		\node[func\pNFunc, font=\funcStyle, anchor=south west] (f#2) at (#2_shape.north west) {
			\ifnum \pNFunc>0 \nodepart{fa} \pFuncA\else\fi
			\ifnum \pNFunc>1 \nodepart{fb} \pFuncB\else\fi
			\ifnum \pNFunc>2 \nodepart{fc} \pFuncC\else\fi
			\ifnum \pNFunc>3 \nodepart{fd} \pFuncD\else\fi
		};
	}
}

% Parallel communication
\pgfkeys{%
	/parcomm/.is family, /parcomm,
	default/.style = {reverse = false, inner type=noinner, outer type=v2vbase , ni=1, no=1, },
 	inner type/.estore in = \pInnerType,
 	outer type/.estore in = \pOuterType,
	ni/.estore in = \pNIn,
	no/.estore in = \pNOut,
	reverse/.is toggle,
}
\tikzset{% 
    noinner/.style={draw=none, inner sep=0pt, minimum height=30pt},
    funcbox/.style={draw=none, fill=\defaultfillcolor, rotate=90, minimum width=30pt, minimum height=10pt},
}
% Generic visually represented parallel communication process
% #1 = environment keys
% #2 = node name
% #3 = node position
\newcommand\parcomm[3][]{
	\pgfkeys{/parcomm, default, #1}%
	\iftoggle{/parcomm/reverse}{
		\node[\pInnerType, rotate=180] (v#2) at (#3) {};
		\node[\pOuterType, draw, inner sep=0pt, fit=(v#2), rotate=180,] (#2_outershape) {};
		\node[i\pNIn o\pNOut, rotate=180, inner sep=0pt, fit=(#2_outershape),] (#2) {};
	}{
		\node[\pInnerType] (v#2) at (#3) {};
		\node[\pOuterType, draw, inner sep=0pt, fit=(v#2),] (#2_outershape) {};
		\node[i\pNIn o\pNOut, inner sep=0pt, fit=(#2_outershape),] (#2) {};
	}
}
% Generic function-based parallel communication process
% #1 = environment keys
% #2 = node name
% #3 = node position
% #4 = function
\newcommand\parcommfunc[4][]{
	\pgfkeys{/parcomm, default, #1}%
	\node[funcbox] (v#2) at (#3) {#4};
	\iftoggle{/parcomm/reverse}{
		\node[\pOuterType, draw, inner sep=1pt, fit=(v#2), rotate=180,] (#2_outershape) {};
		\node[i\pNIn o\pNOut, rotate=180, inner sep=0pt, fit=(#2_outershape),] (#2) {};
	}{
		\node[\pOuterType, draw, inner sep=1pt, fit=(v#2),] (#2_outershape) {};
		\node[i\pNIn o\pNOut, inner sep=0pt, fit=(#2_outershape),] (#2) {};
	}
}
