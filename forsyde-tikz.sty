% A simple library for signal flow diagrams
% based on the pgf/tikz package of Till Tantau
%
% Author: Dr. Karlheinz Ochs, Ruhr-University of Bochum, Germany
% Version: 0.1
% Date: 2007/01/05
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{pgfplots}
\RequirePackage{pgfkeys}
\RequirePackage{xparse}
\RequirePackage{todonotes} % WHA?!
\RequirePackage{ezkeys}
\usetikzlibrary{decorations.markings, shapes, calc, fit, backgrounds}

\ProvidesPackage{forsyde-tikz}
              [2014/12/01 v0.1 ForSyDe TikZ Library]

%
% Libraries for signal flow diagrams.
%
\usetikzlibrary{fsignals,fshapes,}


%%%%%%%%%%%%%
% CONSTANTS %
%%%%%%%%%%%%%
% Colors
\newcommand{\defaultdrawcolor}{black}     		% draw color of signal paths
\newcommand{\defaultfillcolor}{white}     		% draw color of signal paths
\definecolor{sycolor}{RGB}{148,183,215}
\definecolor{ctcolor}{RGB}{225,119,19}
\definecolor{decolor}{RGB}{80,229,154}
\definecolor{sdfcolor}{RGB}{220,220,20}
\definecolor{blackboxcolor}{gray}{0.80}
% line widths of
\newlength{\sepq}
\pgfmathsetlength{\sepq}{2pt}                % constant for small inter-node separation (used for example in function nodes)
\newcommand{\compositelinewidth}{.4pt}       % composite process line width
\newcommand{\skeletonlinewidth}{1pt}         % parallel processes line width
\newcommand{\signalpathlinewidth}{1pt}       % signal paths
\newcommand{\functionpathlinewidth}{.8pt}    % function paths
\newcommand{\vectorpathlinewidth}{4pt}       % vector paths
% sizes, etc.
\newcommand{\tokensize}{3.5pt}
\newcommand{\halftokensize}{1.75pt}
\newcommand{\vectorportsize}{3pt}
\newcommand{\signalportsize}{2pt}

%%%%%%%%%%%%%%%%%%%%%%%%
% GENERIC TIKZ HELPERS %
%%%%%%%%%%%%%%%%%%%%%%%%
% Positioning of node text.
% #1 = node label
% #2 = label text
\newcommand{\textaboveof}[2]{\pgftext[bottom,at=\pgfpointanchor{#1}{north},y=+1mm]{#2}}%
\newcommand{\textrightof}[2]{\pgftext[left,  at=\pgfpointanchor{#1}{east}, x=+1mm]{#2}}%
\newcommand{\textbelowof}[2]{\pgftext[top,   at=\pgfpointanchor{#1}{south},y=-1mm]{#2}}%
\newcommand{\textleftof} [2]{\pgftext[right, at=\pgfpointanchor{#1}{west}, x=-1mm]{#2}}%

\makeatletter
\newcounter{r}
\newcommand{\tikzgrid}{%
  \pgfsetxvec{\pgfpoint{\tikz@node@distance}{0mm}}%
  \pgfsetyvec{\pgfpoint{0mm}{\tikz@node@distance}}%
  \tikz@matrix%
}
\newcommand{\tikz@matrix}[1]{\tikz@@matrix#1@}%
\def\tikz@@matrix#1@{\do@rows#1\\@\\}%
\def\do@rows#1\\{%
  \ifx#1@%
  \else%
    \setcounter{r}{0}%
    \do@columns#1&@&%
    \pgftransformshift{\pgfpointxy{-\ther}{-1}}%
    \expandafter\do@rows%
  \fi}%
\def\do@columns#1&{%
  \if#1@%
  \else%
    \stepcounter{r}%
    \pgftransformshift{\pgfpointxy{1}{0}}%
    #1;%
    \expandafter\do@columns%
  \fi}%
\makeatother

%%%%%%%%%%%%%%%%
% ENVIRONMENTS %
%%%%%%%%%%%%%%%%
\newif\ifnolabel
\newif\ifnocolor
\pgfkeys{
	/tikz/nomoccolor/.is if=nocolor,
	/tikz/nomoclabel/.is if=nolabel,
	/tikz/type style/.store in = \typeStyle,
	/tikz/type style = \scriptsize\textit,
	/tikz/label style/.store in = \labelStyle,
	/tikz/label style = \textbf,
	/tikz/function style/.store in = \funcStyle,
	/tikz/function style = \scriptsize,
	/tikz/moc/.store in = \MoC,
	/tikz/moc = none,
	/tikz/mocin/.store in = \MoCin,
	/tikz/mocin = none,
	/tikz/mocout/.store in = \MoCout,
	/tikz/mocout = none,
}
\pgfkeys{
	/applicative/.is family, /applicative,
	default/.style = {moc=none, reverse = false, type= , ni=1, no=1, nf=0, f1=$ f_1 $, f2=$ f_2 $, f3=$ f_3 $, f4=$ f_4 $, line sep=0pt},
 	moc/.estore in = \pMoc,
 	type/.estore in = \pType,
	ni/.estore in = \pNIn,
	no/.estore in = \pNOut,
	nf/.estore in = \pNFunc,
	f1/.estore in = \pFuncA,
	f2/.estore in = \pFuncB,
	f3/.estore in = \pFuncC,
	f4/.estore in = \pFuncD,
	line sep/.estore in = \pLineSep,
	reverse/.is toggle,
}
\pgfkeys{
	/primitive/.is family, /primitive,
	default/.style = {moc=none, reverse = false, type= , ni=1, no=1,},
 	moc/.estore in = \pMoc,
 	type/.estore in = \pType,
	ni/.estore in = \pNIn,
	no/.estore in = \pNOut,
	reverse shape/.is toggle,
	reverse/.is toggle,
}
\pgfkeys{
	/interface/.is family, /interface,
	default/.style = {mocin = none, mocout = none, },
 	mocin/.estore in = \pMocIn,
 	mocout/.estore in = \pMocOut,
}
\newcommand{\getmoclabel}[1]{
	\ifthenelse{\equal{#1}{sy}}{SY}{
	\ifthenelse{\equal{#1}{de}}{DE}{
	\ifthenelse{\equal{#1}{ct}}{CT}{
	\ifthenelse{\equal{#1}{sdf}}{SDF}{}}}} 
}

%%%%%%%%%%%%%%%%%
% GENERIC NODES %
%%%%%%%%%%%%%%%%%

% Generic applicative leaf process
% #1 = environment keys
% #2 = node name
% #3 = node position
% #4 = node label
\newcommand{\applicative}[4][]{
	\pgfkeys{/applicative, default, #1}%
	\node[inner sep=0pt] (#2_label) at (#3) {\labelStyle{#4}};
	\node[func\pNFunc, font=\funcStyle, yshift=2\sepq+\pLineSep, anchor=south] (f#2) at (#2_label.north) {
		\ifnum \pNFunc>0 \nodepart{fa} \pFuncA\else\fi
		\ifnum \pNFunc>1 \nodepart{fb} \pFuncB\else\fi
		\ifnum \pNFunc>2 \nodepart{fc} \pFuncC\else\fi
		\ifnum \pNFunc>3 \nodepart{fd} \pFuncD\else\fi
	};
	\node[anchor=north, yshift=-\pLineSep] (#2_type) at (#2_label.south) {\typeStyle{\pType\ifnolabel\else\getmoclabel{\pMoc}\fi}};
	\iftoggle{/applicative/reverse}
		{\node[i\pNIn o\pNOut, rotate=180, inner sep=0pt, fit=(f#2)(#2_label)(#2_type),] (#2) {};}
		{\node[i\pNIn o\pNOut, inner sep=0pt, fit=(f#2)(#2_label)(#2_type),] (#2) {};}
	\begin{pgfonlayer}{background}
		\node[applshape, draw, moc=\pMoc, inner sep=0pt, fit=(f#2)(#2_label)(#2_type)] {};
	\end{pgfonlayer}
}


% Generic primite box-shaped leaf process
% #1 = environment keys
% #2 = node name
% #3 = node position
% #4 = node label
\newcommand{\primitivebox}[4][]{
	\applicative[#1, nf=0, line sep=-2pt]{#2}{#3}{#4}
}
% Generic primite special-shaped leaf process
% #1 = environment keys
% #2 = node name
% #3 = node position
\newcommand{\primitivespecial}[4][]{
	\pgfkeys{/primitive, default, #1}%
	\pgfmathsetlength{\foo}{max(\pNIn,\pNOut)*5pt}
	\iftoggle{/primitive/reverse shape}
		{\node[\pType, draw, moc=\pMoc, inner sep=\foo, rotate=180,] (#2_shape) at (#3) {};}	
		{\node[\pType, draw, moc=\pMoc, inner sep=\foo,] (#2_shape) at (#3) {};}	
	\iftoggle{/primitive/reverse}
		{\node[i\pNIn o\pNOut, rotate=180, inner sep=0pt, fit=(#2_shape),] (#2) {};}
		{\node[i\pNIn o\pNOut, inner sep=0pt, fit=(#2_shape),] (#2) {};}
}

