\title{The \textsc{ForSyDe-TikZ} package}
\author{
        George Ungureanu \\
                Department of Electronic Systems\\
        KTH---Royal Institute of Technology\\
        Stockholm, SWEDEN
}
\date{\today}

\documentclass[10pt]{article}
\usepackage{forsyde-tikz}
\usepackage[footnotesize]{caption}
\usepackage{hyperref}
\pgfplotsset{compat=1.9}


\tikzset{% 
    anch/.style={circle, draw=none, fill=red, inner sep=0pt, minimum size=3pt},
    label/.style={font=\ttfamily\scriptsize}
}

\begin{document}
\maketitle

\begin{abstract}
This document is the reference manual for the \textsc{ForSyDe-TikZ} and \textsc{ForSyDe-PC} packages. A new feature in the library should be reflected and documented in this manual.
\end{abstract}

\section{Introduction}

\textsc{ForSyDe-TikZ} is a collection \textsc{TikZ} \& \textsc{PGF} shapes and environments for the \textsc{ForSyDe} methodology. (...)

\textsc{ForSyDe-PC} is a library of helpers for \textsc{ForSyDe} process constructors.

\section{Installation}

...


\section{The ForSyDe-TikZ package}

The \textsc{ForSYDe-TikZ} package is included with

\begin{verbatim}
	\usepackage{forsyde-tikz}
\end{verbatim}

\subsection{Environments \& process networks}

...

\subsection{Leaf processes}

Leaf processes are basic nodes in a process network.

\subsubsection{Applicative processes} \label{tikz_applicative}

These processes which apply a function passed by the user on a set of input signals. The package contains a macro for drawing a custom applicative process used in the following way:

\begin{verbatim}
	\applicative[options]{id}{position}{label}
\end{verbatim}

The \texttt{options} are:
\begin{itemize}
\item \texttt{moc=[none,ct,de,sy,sdf]} the model of computation. Defaut is \texttt{none}.
\item \texttt{type=} the process type. It will be shown below the label.
\item \texttt{ni=[0..7]} the number of input ports. Default is 1.
\item \texttt{no=[0..7]} the number of output ports. Default is 1.
\item \texttt{nf=[0..4]} the number of passed functions. Default is 1.
\item \texttt{f1=} the first function label. It will be shown in the appropriate place in case \texttt{nf > 0}. Default is $f_1$.
\item \texttt{f2=} the second function label. It will be shown in the appropriate place in case \texttt{nf > 1}. Default is $f_2$.
\item \texttt{f3=} the third function label. It will be shown in the appropriate place in case \texttt{nf > 2}. Default is $f_3$.
\item \texttt{f4=} the fourth function label. It will be shown in the appropriate place in case \texttt{nf > 3}. Default is $f_4$.
\item\texttt{line sep=} vertical distance between the function labels, process label and process type. Deault is \texttt{0pt}.
\item\texttt{reverse} toggle switch which determines the orientation of the input/output ports. Default is off (inputs to the left and outputs to the right).

\end{itemize}

An example, showing the available anchors:
\begin{verbatim}
\applicative[moc=ct, type=comb, nf=4, ni=2, no=3, f1=$x/y$ f2=$a+b$] 
{p1}{0,0}{P2};
\applicative[moc=sy, reverse, type=comb, nf=4, ni=2, no=5, f2=$a+b$, 
line sep=3pt] {p2}{6,0}{P2};
\end{verbatim}
\begin{figure}[htb!]\centering
\begin{tikzpicture}[]
\applicative[moc=ct, type=comb, nf=4, ni=2, no=3, f1=$x/y$, f2=$a+b$] {p1}{0,0}{P1};
\applicative[moc=sy, reverse, type=comb, nf=4, ni=2, no=5, f2=$a+b$,line sep=3pt] {p2}{6,0}{P2};

\node[anch] (a) at (p1.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p1.i1}};
\node[anch] (a) at (p1.i2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p1.i2}};
\node[anch] (a) at (p1.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{p1.o1}};
\node[anch] (a) at (p1.o2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{p1.o2}};
\node[anch] (a) at (p1.o3) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{p1.o3}};
\node[anch] (a) at (fp1.f1) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp1.f1}};
\node[anch] (a) at (fp1.f2) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp1.f2}};
\node[anch] (a) at (fp1.f3) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp1.f3}};
\node[anch] (a) at (fp1.f4) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp1.f4}};

\node[anch] (a) at (p2.i1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{p2.i1}};
\node[anch] (a) at (p2.i2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{p2.i2}};
\node[anch] (a) at (p2.o1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p2.o1}};
\node[anch] (a) at (p2.o2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p2.o2}};
\node[anch] (a) at (p2.o3) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p2.o3}};
\node[anch] (a) at (p2.o4) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p2.o4}};
\node[anch] (a) at (p2.o5) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p2.o5}};
\node[anch] (a) at (fp2.f1) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp2.f1}};
\node[anch] (a) at (fp2.f2) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp2.f2}};
\node[anch] (a) at (fp2.f3) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp2.f3}};
\node[anch] (a) at (fp2.f4) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp2.f4}};
\end{tikzpicture}
\end{figure}

\subsubsection{Primitive processes}

These are processes which do not take any function as argument. They may either be represented as a box node similar to \autoref{tikz_applicative} or as a special shape. Thus you are provided with two macros:

\begin{verbatim}
	\primitivebox[options]{id}{position}{label}
	\primitivespecial[options]{id}{position}
\end{verbatim}

The \texttt{options} are:
\begin{itemize}
\item \texttt{moc=[none,ct,de,sy,sdf]} the model of computation. Defaut is \texttt{none}.
\item \texttt{type=} the process type. It will either be shown below the label or choose the node shape. For a list of available shapes check \autoref{appendix_shapes}.
\item \texttt{ni=[0..7]} the number of input ports. Default is 1.
\item \texttt{no=[0..7]} the number of output ports. Default is 1.
\item\texttt{reverse} toggle switch which determines the orientation of the input/output ports. Default is off (inputs to the left and outputs to the right).
\item\texttt{reverse shape} toggle switch which determines the orientation of the chosen shape. Default is off.
\end{itemize}

An example, showing the available anchors:
\begin{verbatim}
\primitivebox[moc=de, type=zip, ni=2, no=1] {box}{0,0}{P2};
\primitivespecial[moc=de, type=zipshape, reverse, reverse shape, 
ni=2, no=1] {spec}{5,0};
\end{verbatim}
\begin{figure}[htb!]\centering
\begin{tikzpicture}[]
\primitivebox[moc=de, type=zip, ni=2, no=1] {box}{0,0}{P2};
\primitivespecial[moc=de, type=zipshape, reverse, reverse shape, ni=2, no=1] {spec}{5,0};

\node[anch] (a) at (box.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{box.i1}};
\node[anch] (a) at (box.i2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{box.i2}};
\node[anch] (a) at (box.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{box.o1}};

\node[anch] (a) at (spec.i1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{spec.i1}};
\node[anch] (a) at (spec.i2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{spec.i2}};
\node[anch] (a) at (spec.o1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{spec.o1}};
\end{tikzpicture}
\end{figure}

\subsubsection{Interface processes}

These are interface processes between different domains of the same MoC (domain interfaces) or between different MoCs (MoC interfaces). The interface process macro syntax is:

\begin{verbatim}
	\interface[options]{id}{position}
\end{verbatim}

The \texttt{options} are:
\begin{itemize}
\item \texttt{mocin=[none,ct,de,sy,sdf]} the input MoC. Defaut is \texttt{none}.
\item \texttt{mocin=[none,ct,de,sy,sdf]} the output MoC. Defaut is \texttt{none}.
\item\texttt{reverse} toggle switch which determines the orientation of the input/output ports. Default is off (inputs to the left and outputs to the right).
\end{itemize}

An example, showing the available anchors:
\begin{verbatim}
\interface[mocin=ct, mocout=de] {di}{0,0};
\interface[mocin=ct, mocout=de, reverse] {direv}{5,0};
\end{verbatim}

\begin{figure}[htb!]\centering
\begin{tikzpicture}[]
\interface[mocin=ct, mocout=de] {di}{0,0};
\interface[mocin=ct, mocout=de, reverse] {direv}{5,0};

\node[anch] (a) at (di.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{di.i1}};
\node[anch] (a) at (di.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{di.o1}};

\node[anch] (a) at (direv.i1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{direv.i1}};
\node[anch] (a) at (direv.o1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{direv.o1}};
\end{tikzpicture}
\end{figure}

\subsection{Composite processes}

Composite processes, from the graphical design point of view, can be regarded as either hierarchical clusters of other processes, or as functional "black boxes". The semantics of composite processes are explained in \texttt{[forsyde:doc]}.

\begin{verbatim}
	\composite[options]{id}{list of clustered nodes}{label}
	\compositebbox[options]{id}{position}{label}
\end{verbatim}

The \texttt{options} are:
\begin{itemize}
\item\texttt{inner sep=} the distance between the outermost clustered nodes and the composite box edge. Default is 15pt.
\item \texttt{ni=[0..7]} the number of input ports. Default is 1.
\item \texttt{no=[0..7]} the number of output ports. Default is 1.
\item\texttt{reverse} toggle switch which determines the orientation of the input/output ports. Default is off (inputs to the left and outputs to the right).
\end{itemize}

An example, showing the available anchors:
\begin{verbatim}
\compositebbox[ni=1, no=1] {bb} {0,0} {BlackBox};
\primitivebox[] {dm1} {6,-0.5} {Dummy1};
\primitivebox {dm2} {6,0.5} {Dummy2};
\composite[ni=2, no=3, inner sep=25pt] {cp1} {(bb)} {CP1};
\composite[ni=2, no=3, reverse] {cp2} {(dm1)(dm2)} {CP2};

\end{verbatim}
\begin{figure}[htb!]\centering
\begin{tikzpicture}
\compositebbox[ni=1, no=1] {bb} {0,0} {BlackBox};
\primitivebox {dm1} {6,-0.5} {Dummy1};
\primitivebox {dm2} {6,0.5} {Dummy2};
\composite[ni=2, no=3, inner sep=25pt] {cp1} {(bb)} {CP1};
\composite[ni=2, no=3, reverse] {cp2} {(dm1)(dm2)} {CP2};

\node[anch] (a) at (bb.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{bb.i1}};
\node[anch] (a) at (bb.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{bb.o1}};

\node[anch] (a) at (cp1.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{cp1.i1}};
\node[anch] (a) at (cp1.i2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{cp1.i2}};
\node[anch] (a) at (cp1.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{cp1.o1}};
\node[anch] (a) at (cp1.o2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{cp1.o2}};
\node[anch] (a) at (cp1.o3) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{cp1.o3}};

\node[anch] (a) at (cp2.i1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{cp2.i1}};
\node[anch] (a) at (cp2.i2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{cp2.i2}};
\node[anch] (a) at (cp2.o1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{cp2.o1}};
\node[anch] (a) at (cp2.o2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{cp2.o2}};
\node[anch] (a) at (cp2.o3) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{cp2.o3}};

\end{tikzpicture}
\end{figure}

\subsection{Parallel processes}

Parallel processes have special symbols that infer homogeneous repetitions of specific structures. The semantics of parallel processes are explained in \texttt{[forsyde:doc]}.

\subsubsection{Parallel computation processes}

Parallel computation processes, from the graphical design point of view, are clusters of processes that infer replication and specific interconnection.

\begin{verbatim}
	\parcomp[options]{id}{list of clustered nodes}{label}
\end{verbatim}

The \texttt{options} are:
\begin{itemize}
\item \texttt{moc=[none,ct,de,sy,sdf]} the model of computation. Defaut is \texttt{none}.
\item \texttt{type=} the process type. It chooses the node shape. For a list of available shapes check \autoref{appendix_shapes}.
\item \texttt{ni=[0..7]} the number of input ports. Default is 1.
\item \texttt{no=[0..7]} the number of output ports. Default is 1.
\item \texttt{nf=[0..4]} the number of passed functions. Default is 1.
\item \texttt{f1=} the first function label. It will be shown in the appropriate place in case \texttt{nf > 0}. Default is $\langle f_1 \rangle$.
\item \texttt{f2=} the second function label. It will be shown in the appropriate place in case \texttt{nf > 1}. Default is $\langle f_2 \rangle$.
\item \texttt{f3=} the third function label. It will be shown in the appropriate place in case \texttt{nf > 2}. Default is $\langle f_3 \rangle$.
\item \texttt{f4=} the fourth function label. It will be shown in the appropriate place in case \texttt{nf > 3}. Default is $\langle f_4 \rangle$.
\item\texttt{inner sep=} the distance between the outermost clustered nodes and the composite box edge. Default is 18pt.
\item\texttt{reverse} toggle switch which determines the orientation of the input/output ports. Default is off (inputs to the left and outputs to the right).
\end{itemize}

An example, showing the available anchors:
\begin{verbatim}
\primitivebox {dm1} {0,-0.5} {Dummy 1};
\primitivebox {dm2} {0,0.5} {Dummy 2};
\primitivebox {dm3} {6,0} {Dummy 3};
\parcomp[ni=2, no=2, nf=2, type=datapar] {dp} {(dm1)(dm2)} {Farm1};
\parcomp[ni=1, no=2, nf=3, f3=scanld (+), type=pipe, reverse] {pr} {(dm3)} {PipeRev1};
\end{verbatim}

\begin{figure}[htb!]\centering
\begin{tikzpicture}
\primitivebox {dm1} {0,-0.5} {Dummy 1};
\primitivebox {dm2} {0,0.5} {Dummy 2};
\primitivebox {dm3} {6,0} {Dummy 3};
\parcomp[ni=2, no=2, nf=2, type=datapar] {dp} {(dm1)(dm2)} {Farm1};
\parcomp[ni=1, no=2, nf=3, f3=scanld (+), type=pipe, reverse] {pr} {(dm3)} {PipeRev1};

\node[anch] (a) at (dp.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{dp.i1}};
\node[anch] (a) at (dp.i2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{dp.i2}};
\node[anch] (a) at (dp.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{dp.o1}};
\node[anch] (a) at (dp.o2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{dp.o2}};
\node[anch] (a) at (fdp.f1) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fdp.f1}};
\node[anch] (a) at (fdp.f2) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fdp.f2}};
\node[anch] (a) at (fdp.f1i) {}; \node[label, anchor=west, rotate=-45] (l) at (a.north) {\texttt{fdp.f1i}};
\node[anch] (a) at (fdp.f2i) {}; \node[label, anchor=west, rotate=-45] (l) at (a.north) {\texttt{fdp.f2i}};

\node[anch] (a) at (pr.i1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{pr.i1}};
\node[anch] (a) at (pr.o1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{pr.o1}};
\node[anch] (a) at (pr.o2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{pr.o2}};
\node[anch] (a) at (fpr.f1) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fpr.f1}};
\node[anch] (a) at (fpr.f2) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fpr.f2}};
\node[anch] (a) at (fpr.f3) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fpr.f3}};
\node[anch] (a) at (fpr.f1i) {}; \node[label, anchor=west, rotate=-45] (l) at (a.north) {\texttt{fpr.f1i}};
\node[anch] (a) at (fpr.f2i) {}; \node[label, anchor=west, rotate=-45] (l) at (a.north) {\texttt{fpr.f2i}};
\node[anch] (a) at (fpr.f3i) {}; \node[label, anchor=west, rotate=-45] (l) at (a.north) {\texttt{fpr.f3i}};
\end{tikzpicture}
\end{figure}

\subsubsection{Parallel communication processes}

Parallel communication processes infer replication and specific interconnection between processes. They are mainly rearranging the data contained by vectors of signals and/or signals of vectors.

\begin{verbatim}
	\parcomm[options]{id}{position}
	\parcommfunc[options]{id}{position}{index function}
\end{verbatim}

The \texttt{options} are:
\begin{itemize}
\item \texttt{inner type=} The inner shape. Default is \texttt{noinner}. For a list of available shapes check \autoref{appendix_shapes}.
\item \texttt{outer type=} The outer shape. Default is \texttt{v2vbase}. For a list of available shapes check \autoref{appendix_shapes}.
\item \texttt{ni=[0..7]} the number of input ports. Default is 1.
\item \texttt{no=[0..7]} the number of output ports. Default is 1.
\item\texttt{reverse} toggle switch which determines the orientation of the input/output ports. Default is off (inputs to the left and outputs to the right).
\end{itemize}

An example, showing the available anchors:
\begin{verbatim}
\parcomm[outer type=s2vbase] {a}{0,0};
\parcommfunc[no=2] {b}{3,0}{$f(i)$};
\parcomm[inner type=standardskeletonbox] {c}{6,0};
\parcomm[inner type=standardskeletonbox, outer type=v2gvbase, 
reverse] {d}{9,0};
\end{verbatim}

\begin{figure}[htb!]\centering
\begin{tikzpicture}
\parcomm[outer type=s2vbase] {a}{0,0};
\parcommfunc[no=2] {b}{3,0}{$f(i)$};
\parcomm[inner type=standardskeletonbox] {c}{6,0};
\parcomm[inner type=standardskeletonbox, outer type=v2gvbase, reverse] {d}{9,0};

\node[anch] (x) at (a.i1) {}; \node[label, anchor=east] (l) at (x.west) {\texttt{a.i1}};
\node[anch] (x) at (a.o1) {}; \node[label, anchor=west] (l) at (x.east) {\texttt{a.o1}};
\node[anch] (x) at (b.i1) {}; \node[label, anchor=east] (l) at (x.west) {\texttt{b.i1}};
\node[anch] (x) at (b.o1) {}; \node[label, anchor=west] (l) at (x.east) {\texttt{b.o1}};
\node[anch] (x) at (b.o2) {}; \node[label, anchor=west] (l) at (x.east) {\texttt{b.o2}};
\foreach \i in {0,1,...,7} {
	\node[anch] (x) at (vc.vi\i) {}; \node[label, anchor=east] (l) at (x.west) {\texttt{vc.vi\i}};
	\node[anch] (x) at (vd.vo\i) {}; \node[label, anchor=east] (l) at (x.west) {\texttt{vd.vo\i}};
	\node[anch] (x) at (vc.vo\i) {}; \node[label, anchor=west] (l) at (x.east) {\texttt{vc.vo\i}};
	\node[anch] (x) at (vd.vi\i) {}; \node[label, anchor=west] (l) at (x.east) {\texttt{vd.vi\i}};
}
\end{tikzpicture}
\end{figure}

\subsection{Paths}

Data flow in ForSyDe is represented with paths. \textsc{ForSyDe-TikZ} provides three macros for drawing signals (\texttt{\string\signal}), vectors (\texttt{\string\vector}) or function interfaces (\texttt{\string\function}) between process anchors. 

All three macros have an \texttt{options} field which accepts the following keys:
\begin{itemize}
\item \texttt{moc=[none,ct,de,sy,sdf]} the model of computation. Defaut is \texttt{none}.
\item \texttt{token=[scalar,vector,function,scalarAE,vectorAE,functionAE]} draws symbols for depicting the token structure of ForSyDe signals or vectors. Function paths will ignore this key. To draw tuple structures you have to separate token keywords by \texttt{-} (dash). E.g.: 3-tuple of scalar, absent extended vector and function can be drawn with \texttt{token=scalar-vectorAE-function}.
\item \texttt{token pos=[0.0 .. 1.0]} the position between the start node/anchor and the end node/anchor where the token begins to be drawn.
\item \texttt{-|-=[0.0 .. 1.0]} will create a horizontal-vertical-horizontal spline in the path. It may be accompanied by a number which determines the position of the 90 degree angle.
\item \texttt{|-|=[0.0 .. 1.0]} will create a vertical-horizontal-vertical spline in the path. It may be accompanied by a number which determines the position of the 90 degree angle.
\item \texttt{-|-=[0.0 .. 1.0]} will create a horizontal-vertical-horizontal spline in the path. It may be accompanied by a number which determines the position of the 90 degree angle.
\item \texttt{-|-|=[0.0 .. 1.0]} will create a horizontal-vertical-horizontal-vertical spline in the path. It may be accompanied by a number which determines the position of the 90 degree angle.
\item \texttt{-|-|-=[0.0 .. 1.0]:[0.0 .. 1.0]} will create a horizontal-vertical-horizontal-vertical-horizontal spline in the path. It may be accompanied by two numbers  separated by \texttt{:} which determine the position of the 90 degree angles.
\item \texttt{|-|-|=[0.0 .. 1.0]:[0.0 .. 1.0]} will create a vertical-horizontal-vertical-horizontal-vertical spline in the path. It may be accompanied by two numbers  separated by \texttt{:} which determine the position of the 90 degree angles.
\item \texttt{deviation=} is a length representing the deviation from the straight path in case of complex splines (\texttt{-|-|},\texttt{-|-|-} and \texttt{|-|-|}).
\end{itemize}

\subsubsection{Signals}

Signals are the only means of transporting data in ForSyDe process networks. For a theoretical background check \texttt{[forsyde:doc]}. 

\begin{verbatim}
	\signal[options] (from) shape (to);	
\end{verbatim}

\textbf{IMPORTANT:} this is a \texttt{\string\def} macro, thus the format has to be strictly respected (spaces, parentheses and semicolon).

An example, showing the available anchors:
\begin{verbatim}
	\signal[] (0,0) -> (1.5,0); 
	\signal[moc=ct, token=vectorAE-functionAE] (2,0) <- (3.5,0);
	\signal[moc=sy, -|-|-=0.2:0.6, deviate=-10pt] (4,0) p->p (5.5,0);
	\signal[token=scalarAE, -|-] (6,-.3) ->p (7.5,.3);
	\signal[token pos=0.4, token=scalar-vector] (8,0) -> (9.5,0);
\end{verbatim}
\begin{figure}[htb!]\centering
\begin{tikzpicture}[]
	\signal[] (0,2) -> (1.5,2); 
	\signal[moc=ct, token=vectorAE-functionAE] (2,2) <- (3.5,2);
	\signal[moc=sy, -|-|-=0.2:0.6, deviate=-10pt] (4,2) p->p (5.5,2);
	\signal[token=scalarAE, -|-] (6,1.7) ->p (7.5,2.3);
	\signal[token pos=0.4, token=scalar-vector] (8,2) -> (9.5,2);
\end{tikzpicture}
\end{figure}

\subsubsection{Vectors}

Vectors can be regarded as homogeneous bundles of signals. The token symbols can depict the structure of the signals composing a vector. For a theoretical background check \texttt{[forsyde:doc]}. 

\begin{verbatim}
	\vector[options] (from) shape (to);	
\end{verbatim}

\textbf{IMPORTANT:} this is a \texttt{\string\def} macro, thus the format has to be strictly respected (spaces, parentheses and semicolon).

An example, showing the available anchors:
\begin{verbatim}
	\vector[token=scalar-scalar-scalar, token pos=0.35] (0,0) p->p (2,0);	
	\vector[moc=sdf] (3,0) p->p (5,0);
	\vector[token=vectorAE] (6,0) p->p (8,0);
\end{verbatim}
\begin{figure}[htb!]\centering
\begin{tikzpicture}[]
	\vector[token=scalar-scalar-scalar, token pos=0.35] (0,1) p->p (2,1);	
	\vector[moc=sdf] (3,1) p->p (5,1);
	\vector[token=vectorAE] (6,1) p->p (8,1);
\end{tikzpicture}
\end{figure}

\subsubsection{Function paths}

The function path may depict relations between functions and processes. For a theoretical background check \texttt{[forsyde:doc]}. 

\begin{verbatim}
	\function[options] (from) shape (to);	
\end{verbatim}

\textbf{IMPORTANT:} this is a \texttt{\string\def} macro, thus the format has to be strictly respected (spaces, parentheses and semicolon).

An example, showing the available anchors:
\begin{verbatim}
	\function[] (0,0) -> (2,0);
	\function[|-|=.6] (3,.5) fi-> (4,-.5);
	\function[|-|-|] (5,.5) <- (5,-.5);
\end{verbatim}
\begin{figure}[htb!]\centering
\begin{tikzpicture}[]
	\function[] (0,0) -> (2,0);
	\function[|-|=.6] (3,.5) fi-> (4,-.5);
	\function[|-|-|] (5,.5) <- (5,-.5);
\end{tikzpicture}
\end{figure}

\subsection{Miscellaneous functions}

Following is a list of miscellaneous functions and environments provided for user convenience:

\begin{itemize}
\item \texttt{\string\textleftof\{node\}\{text\}}
\item \texttt{\string\textrightof\{node\}\{text\}}
\item \texttt{\string\textaboveof\{node\}\{text\}}
\item \texttt{\string\textbelowof\{node\}\{text\}}
\end{itemize}

\subsection{Further customizing the environment}

The following commands can be used in the document preamble for changing environment variables.
\begin{verbatim}
% Colors
\renewcommand{\defaultdrawcolor}{[color]}
\renewcommand{\defaultfillcolor}{[color]}
\definecolor{sycolor}{[coord sys]}{[color coord]}
\definecolor{ctcolor}{[coord sys]}{[color coord]}
\definecolor{decolor}{[coord sys]}{[color coord]}
\definecolor{sdfcolor}{[coord sys]}{[color coord]}
\definecolor{blackboxcolor}{[coord sys]}{[color coord]}}
% line widths
\pgfmathsetlength{\sepq}{[size]}           % small inter-node separation 
\renewcommand{\compositelinewidth}{[size]}
\renewcommand{\skeletonlinewidth}{[size]}  % parallel processes line width
\renewcommand{\signalpathlinewidth}{[size]}
\renewcommand{\functionpathlinewidth}{[size]}
\renewcommand{\vectorpathlinewidth}{[size]}
% sizes, etc.
\renewcommand{\tokensize}{[size]}
\renewcommand{\halftokensize}{[size]}
\renewcommand{\vectorportsize}{[size]}
\renewcommand{\signalportsize}{[size]}
\end{verbatim}

\section{The ForSyDe-PC package}

The \textsc{ForSyDe-PC} package includes ForSyDe process constructors, written as macros. For a detailed theoretical background in process constructors check \texttt{[forsyde:doc]}. It is included with: 

\begin{verbatim}
	\usepackage{forsyde-pc}
\end{verbatim}

Following is a list with all process constructors including valid option keys:

\begin{verbatim}
\delay    [moc=,f1=,line sep=,reverse]        {id}{pos}{label}
\delayn   [moc=,f1=,f2=,line sep=,reverse]    {id}{pos}{label}
\map      [moc=,f1=,line sep=,reverse]        {id}{pos}{label}
\comb     [moc=,f1=,line sep=,reverse]        {id}{pos}{label}
\combII   [moc=,f1=,line sep=,reverse]        {id}{pos}{label}
\combIII  [moc=,f1=,line sep=,reverse]        {id}{pos}{label}
\combIV   [moc=,f1=,line sep=,reverse]        {id}{pos}{label}
\scanl    [moc=,f1=,f2=,line sep=,reverse]    {id}{pos}{label}
\scanlII  [moc=,f1=,f2=,line sep=,reverse]    {id}{pos}{label}
\scanlIII [moc=,f1=,f2=,line sep=,reverse]    {id}{pos}{label}
\scanld   [moc=,f1=,f2=,f3=,line sep=,reverse]{id}{pos}{label}
\scanldII [moc=,f1=,f2=,f3=,line sep=,reverse]{id}{pos}{label}
\scanldIII[moc=,f1=,f2=,f3=,line sep=,reverse]{id}{pos}{label}
\moore    [moc=,f1=,f2=,f3=,line sep=,reverse]{id}{pos}{label}
\mooreII  [moc=,f1=,f2=,f3=,line sep=,reverse]{id}{pos}{label}
\mooreIII [moc=,f1=,f2=,f3=,line sep=,reverse]{id}{pos}{label}
\mealy    [moc=,f1=,f2=,f3=,line sep=,reverse]{id}{pos}{label}
\mealyII  [moc=,f1=,f2=,f3=,line sep=,reverse]{id}{pos}{label}
\mealyIII [moc=,f1=,f2=,f3=,line sep=,reverse]{id}{pos}{label}
\source   [moc=,f1=,f2=,line sep=,reverse]    {id}{pos}{label}
\filter   [moc=,f1=,f2=,line sep=,reverse]    {id}{pos}{label}
\hold     [moc=,f1=,line sep=,reverse]        {id}{pos}{label}
\fillS    [moc=,f1=,f2=,line sep=,reverse]    {id}{pos}{label}

\zip     [moc=,reverse]{id}{pos}
\zipIII  [moc=,reverse]{id}{pos}
\zipIV   [moc=,reverse]{id}{pos}
\zipV    [moc=,reverse]{id}{pos}
\zipVI   [moc=,reverse]{id}{pos}
\unzip   [moc=,reverse]{id}{pos}
\unzipIII[moc=,reverse]{id}{pos}
\unzipIV [moc=,reverse]{id}{pos}
\unzipV  [moc=,reverse]{id}{pos}
\unzipVI [moc=,reverse]{id}{pos}

\dataparallel[ni=,no=,inner sep=,reverse]    {id}{included}{label}
\farm        [ni=,no=,f1=,inner sep=,reverse]{id}{included}{label}
\pipe        [ni=,no=,inner sep=,reverse]    {id}{included}{label}
\reduce      [ni=,no=,inner sep=,reverse]    {id}{included}{label}

\unzipx  [reverse]{id}{pos}
\zipx    [reverse]{id}{pos}
\oddsV   [reverse]{id}{pos}
\evensV  [reverse]{id}{pos}
\reverseV[reverse]{id}{pos}
\groupV  [reverse]{id}{pos}
\concatV [reverse]{id}{pos}

\end{verbatim}

%\newcommand\evensV[2][]{%
%	\parcomm[#1, outer type=v2vbase]{#2}{#3};
%	\foreach \i in {1,3,...,7} {
%		\draw[line width=.3pt] (v#2.vi\i) -- (v#2.vo\i);
%	}
%}
%\newcommand\reverseV[2][]{%
%	\parcomm[#1, outer type=v2vbase]{#2}{#3};
%	\foreach \i in {0,1,...,7} {
%		\pgfmathtruncatemacro\result{7-\i}
%		\draw[line width=.3pt] (v#2.vi\i) -- (v#2.vo\result);
%	}
%}
%\newcommand\groupV[2][]{%
%	\parcomm[#1, outer type=v2gbase]{#2}{#3};
%	\foreach \i in {0,1,...,7} {
%		\draw[line width=.3pt] (v#2.vi\i) -- (v#2.vo\i);
%	}
%}
%\newcommand\concatV[2][]{%
%	\parcomm[#1, outer type=v2gbase]{#2}{#3};
%	\foreach \i in {0,1,...,7} {
%		\draw[line width=.3pt] (v#2.vi\i) -- (v#2.vo\i);
%	}
%}

\newpage
\appendix
\section{PGF nodes} \label{appendix_shapes}

\end{document}