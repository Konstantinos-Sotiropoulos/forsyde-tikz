\title{The \textsc{ForSyDe-TikZ} package}
\author{
        George Ungureanu \\
                Department of Electronic Systems\\
        KTH---Royal Institute of Technology\\
        Stockholm, SWEDEN
}
\date{\today}

\documentclass[10pt]{article}
\usepackage{forsyde-tikz}
\usepackage[footnotesize]{caption}
\usepackage{hyperref}
\pgfplotsset{compat=1.9}


\tikzset{% 
    anch/.style={circle, draw=none, fill=red, inner sep=0pt, minimum size=3pt},
    label/.style={font=\ttfamily\scriptsize}
}

\begin{document}
\maketitle

\begin{abstract}
This document is the reference manual for the \textsc{ForSyDe-TikZ} and \textsc{ForSyDe-ProcCons} packages. A new feature in the library should be reflected and documented in this manual.
\end{abstract}

\section{Introduction}

\textsc{ForSyDe-TikZ} is a collection \textsc{TikZ} \& \textsc{PGF} shapes and environments for the \textsc{ForSyDe} methodology. (...)

\textsc{ForSyDe-ProcCons} is a library of helpers for \textsc{ForSyDe} process constructors.

\section{Installation}

...


\section{The ForSyDe-TikZ package}

The \textsc{ForSYDe-TikZ} package is included with

\begin{verbatim}
	\usepackage{forsyde-tikz}
\end{verbatim}

\subsection{Environments \& process networks}

...

\subsection{Signals}

...

\subsection{Leaf processes}

Leaf processes are basic nodes in a process network.

\subsubsection{Applicative processes} \label{tikz_applicative}

These processes which apply a function passed by the user on a set of input signals. The package contains a macro for drawing a custom applicative process used in the following way:

\begin{verbatim}
	\applicative[options]{id}{position}{label}
\end{verbatim}

The \texttt{options} are:
\begin{itemize}
\item \texttt{moc=[none,ct,de,sy,sdf]} the model of computation. Defaut is \texttt{none}.
\item \texttt{type=} the process type. It will be shown below the label.
\item \texttt{ni=[0..7]} the number of input ports. Default is 1.
\item \texttt{no=[0..7]} the number of output ports. Default is 1.
\item \texttt{nf=[0..4]} the number of passed functions. Default is 1.
\item \texttt{f1=} the first function label. It will be shown in the appropriate place in case \texttt{nf > 0}. Default is $f_1$.
\item \texttt{f2=} the second function label. It will be shown in the appropriate place in case \texttt{nf > 1}. Default is $f_2$.
\item \texttt{f3=} the third function label. It will be shown in the appropriate place in case \texttt{nf > 2}. Default is $f_3$.
\item \texttt{f4=} the fourth function label. It will be shown in the appropriate place in case \texttt{nf > 3}. Default is $f_4$.
\item\texttt{line sep=} vertical distance between the function labels, process label and process type. Deault is \texttt{0pt}.
\item\texttt{reverse} toggle switch which determines the orientation of the input/output ports. Default is off (inputs to the left and outputs to the right).

\end{itemize}

An example, showing the available anchors:
\begin{verbatim}
\applicative[moc=ct, type=comb, nf=4, ni=2, no=3, f1=$x/y$ f2=$a+b$] 
{p1}{0,0}{P2};
\applicative[moc=sy, reverse, type=comb, nf=4, ni=2, no=5, f2=$a+b$, 
line sep=3pt] {p2}{6,0}{P2};
\end{verbatim}
\begin{figure}[htb!]\centering
\begin{tikzpicture}[]
\applicative[moc=ct, type=comb, nf=4, ni=2, no=3, f1=$x/y$, f2=$a+b$] {p1}{0,0}{P1};
\applicative[moc=sy, reverse, type=comb, nf=4, ni=2, no=5, f2=$a+b$,line sep=3pt] {p2}{6,0}{P2};

\node[anch] (a) at (p1.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p1.i1}};
\node[anch] (a) at (p1.i2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p1.i2}};
\node[anch] (a) at (p1.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{p1.o1}};
\node[anch] (a) at (p1.o2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{p1.o2}};
\node[anch] (a) at (p1.o3) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{p1.o3}};
\node[anch] (a) at (fp1.f1) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp1.f1}};
\node[anch] (a) at (fp1.f2) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp1.f2}};
\node[anch] (a) at (fp1.f3) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp1.f3}};
\node[anch] (a) at (fp1.f4) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp1.f4}};

\node[anch] (a) at (p2.i1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{p2.i1}};
\node[anch] (a) at (p2.i2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{p2.i2}};
\node[anch] (a) at (p2.o1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p2.o1}};
\node[anch] (a) at (p2.o2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p2.o2}};
\node[anch] (a) at (p2.o3) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p2.o3}};
\node[anch] (a) at (p2.o4) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p2.o4}};
\node[anch] (a) at (p2.o5) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{p2.o5}};
\node[anch] (a) at (fp2.f1) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp2.f1}};
\node[anch] (a) at (fp2.f2) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp2.f2}};
\node[anch] (a) at (fp2.f3) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp2.f3}};
\node[anch] (a) at (fp2.f4) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fp2.f4}};
\end{tikzpicture}
\end{figure}

\subsubsection{Primitive processes}

These are processes which do not take any function as argument. They may either be represented as a box node similar to \autoref{tikz_applicative} or as a special shape. Thus you are provided with two macros:

\begin{verbatim}
	\primitivebox[options]{id}{position}{label}
	\primitivespecial[options]{id}{position}
\end{verbatim}

The \texttt{options} are:
\begin{itemize}
\item \texttt{moc=[none,ct,de,sy,sdf]} the model of computation. Defaut is \texttt{none}.
\item \texttt{type=} the process type. It will either be shown below the label or choose the node shape. For a list of available shapes check \autoref{appendix_shapes}.
\item \texttt{ni=[0..7]} the number of input ports. Default is 1.
\item \texttt{no=[0..7]} the number of output ports. Default is 1.
\item\texttt{reverse} toggle switch which determines the orientation of the input/output ports. Default is off (inputs to the left and outputs to the right).
\item\texttt{reverse shape} toggle switch which determines the orientation of the chosen shape. Default is off.
\end{itemize}

An example, showing the available anchors:
\begin{verbatim}
\primitivebox[moc=de, type=zip, ni=2, no=1] {box}{0,0}{P2};
\primitivespecial[moc=de, type=zipshape, reverse, reverse shape, 
ni=2, no=1] {spec}{5,0};
\end{verbatim}
\begin{figure}[htb!]\centering
\begin{tikzpicture}[]
\primitivebox[moc=de, type=zip, ni=2, no=1] {box}{0,0}{P2};
\primitivespecial[moc=de, type=zipshape, reverse, reverse shape, ni=2, no=1] {spec}{5,0};

\node[anch] (a) at (box.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{box.i1}};
\node[anch] (a) at (box.i2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{box.i2}};
\node[anch] (a) at (box.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{box.o1}};

\node[anch] (a) at (spec.i1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{spec.i1}};
\node[anch] (a) at (spec.i2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{spec.i2}};
\node[anch] (a) at (spec.o1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{spec.o1}};
\end{tikzpicture}
\end{figure}

\subsubsection{Interface processes}

These are interface processes between different domains of the same MoC (domain interfaces) or between different MoCs (MoC interfaces). The interface process macro syntax is:

\begin{verbatim}
	\interface[options]{id}{position}
\end{verbatim}

The \texttt{options} are:
\begin{itemize}
\item \texttt{mocin=[none,ct,de,sy,sdf]} the input MoC. Defaut is \texttt{none}.
\item \texttt{mocin=[none,ct,de,sy,sdf]} the output MoC. Defaut is \texttt{none}.
\item\texttt{reverse} toggle switch which determines the orientation of the input/output ports. Default is off (inputs to the left and outputs to the right).
\end{itemize}

An example, showing the available anchors:
\begin{verbatim}
\interface[mocin=ct, mocout=de] {di}{0,0};
\interface[mocin=ct, mocout=de, reverse] {direv}{5,0};
\end{verbatim}

\begin{figure}[htb!]\centering
\begin{tikzpicture}[]
\interface[mocin=ct, mocout=de] {di}{0,0};
\interface[mocin=ct, mocout=de, reverse] {direv}{5,0};

\node[anch] (a) at (di.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{di.i1}};
\node[anch] (a) at (di.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{di.o1}};

\node[anch] (a) at (direv.i1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{direv.i1}};
\node[anch] (a) at (direv.o1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{direv.o1}};
\end{tikzpicture}
\end{figure}

\subsection{Composite processes}

Composite processes, from the graphical design point of view, can be regarded as either hierarchical clusters of other processes, or as functional "black boxes". The semantics of composite processes are explained in \texttt{[forsyde:doc]}.

\begin{verbatim}
	\composite[options]{id}{list of clustered nodes}{label}
	\compositebbox[options]{id}{position}{label}
\end{verbatim}

The \texttt{options} are:
\begin{itemize}
\item\texttt{inner sep=} the distance between the outermost clustered nodes and the composite box edge. Default is 15pt.
\item \texttt{ni=[0..7]} the number of input ports. Default is 1.
\item \texttt{no=[0..7]} the number of output ports. Default is 1.
\item\texttt{reverse} toggle switch which determines the orientation of the input/output ports. Default is off (inputs to the left and outputs to the right).
\end{itemize}

An example, showing the available anchors:
\begin{verbatim}
\compositebbox[ni=1, no=1] {bb} {0,0} {BlackBox};
\primitivebox[] {dm1} {6,-0.5} {Dummy1};
\primitivebox[] {dm2} {6,0.5} {Dummy2};
\composite[ni=2, no=3, inner sep=25pt] {cp1} {(bb)} {CP1};
\composite[ni=2, no=3, reverse] {cp2} {(dm1)(dm2)} {CP2};

\end{verbatim}
\begin{figure}[htb!]\centering
\begin{tikzpicture}[]
\compositebbox[ni=1, no=1] {bb} {0,0} {BlackBox};
\primitivebox[] {dm1} {6,-0.5} {Dummy1};
\primitivebox[] {dm2} {6,0.5} {Dummy2};
\composite[ni=2, no=3, inner sep=25pt] {cp1} {(bb)} {CP1};
\composite[ni=2, no=3, reverse] {cp2} {(dm1)(dm2)} {CP2};

\node[anch] (a) at (bb.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{di.i1}};
\node[anch] (a) at (bb.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{di.o1}};

\node[anch] (a) at (cp1.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{cp1.i1}};
\node[anch] (a) at (cp1.i2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{cp1.i2}};
\node[anch] (a) at (cp1.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{cp1.o1}};
\node[anch] (a) at (cp1.o2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{cp1.o2}};
\node[anch] (a) at (cp1.o3) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{cp1.o3}};

\node[anch] (a) at (cp2.i1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{cp2.i1}};
\node[anch] (a) at (cp2.i2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{cp2.i2}};
\node[anch] (a) at (cp2.o1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{cp2.o1}};
\node[anch] (a) at (cp2.o2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{cp2.o2}};
\node[anch] (a) at (cp2.o3) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{cp2.o3}};

\end{tikzpicture}
\end{figure}

\subsection{Parallel processes}

Parallel processes have special symbols that infer homogeneous repetitions of specific structures. The semantics of parallel processes are explained in \texttt{[forsyde:doc]}.

\subsubsection{Parallel computation processes}

Parallel computation processes, from the graphical design point of view, are clusters of processes that infer replication and specific interconnection.

\begin{verbatim}
	\parcomp[options]{id}{list of clustered nodes}{label}
\end{verbatim}

The \texttt{options} are:
\begin{itemize}
\item \texttt{moc=[none,ct,de,sy,sdf]} the model of computation. Defaut is \texttt{none}.
\item \texttt{type=} the process type. It chooses the node shape. For a list of available shapes check \autoref{appendix_shapes}.
\item \texttt{ni=[0..7]} the number of input ports. Default is 1.
\item \texttt{no=[0..7]} the number of output ports. Default is 1.
\item \texttt{nf=[0..4]} the number of passed functions. Default is 1.
\item \texttt{f1=} the first function label. It will be shown in the appropriate place in case \texttt{nf > 0}. Default is $\langle f_1 \rangle$.
\item \texttt{f2=} the second function label. It will be shown in the appropriate place in case \texttt{nf > 1}. Default is $\langle f_2 \rangle$.
\item \texttt{f3=} the third function label. It will be shown in the appropriate place in case \texttt{nf > 2}. Default is $\langle f_3 \rangle$.
\item \texttt{f4=} the fourth function label. It will be shown in the appropriate place in case \texttt{nf > 3}. Default is $\langle f_4 \rangle$.
\item\texttt{inner sep=} the distance between the outermost clustered nodes and the composite box edge. Default is 18pt.
\item\texttt{reverse} toggle switch which determines the orientation of the input/output ports. Default is off (inputs to the left and outputs to the right).
\end{itemize}

An example, showing the available anchors:
\begin{verbatim}
\primitivebox[] {dm1} {0,-0.5} {Dummy 1};
\primitivebox[] {dm2} {0,0.5} {Dummy 2};
\primitivebox[] {dm3} {6,0} {Dummy 3};
\parcomp[ni=2, no=2, nf=2, type=datapar] {dp} {(dm1)(dm2)} {Farm1};
\parcomp[ni=1, no=2, nf=3, f3=scanld (+), type=pipe, reverse] {pr} {(dm3)} {PipeRev1};
\end{verbatim}

\begin{figure}[htb!]\centering
\begin{tikzpicture}[]
\primitivebox[] {dm1} {0,-0.5} {Dummy 1};
\primitivebox[] {dm2} {0,0.5} {Dummy 2};
\primitivebox[] {dm3} {6,0} {Dummy 3};
\parcomp[ni=2, no=2, nf=2, type=datapar] {dp} {(dm1)(dm2)} {Farm1};
\parcomp[ni=1, no=2, nf=3, f3=scanld (+), type=pipe, reverse] {pr} {(dm3)} {PipeRev1};

\node[anch] (a) at (dp.i1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{dp.i1}};
\node[anch] (a) at (dp.i2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{dp.i2}};
\node[anch] (a) at (dp.o1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{dp.o1}};
\node[anch] (a) at (dp.o2) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{dp.o2}};
\node[anch] (a) at (fdp.f1) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fdp.f1}};
\node[anch] (a) at (fdp.f2) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fdp.f2}};
\node[anch] (a) at (fdp.f1i) {}; \node[label, anchor=west, rotate=-45] (l) at (a.north) {\texttt{fdp.f1i}};
\node[anch] (a) at (fdp.f2i) {}; \node[label, anchor=west, rotate=-45] (l) at (a.north) {\texttt{fdp.f2i}};

\node[anch] (a) at (pr.i1) {}; \node[label, anchor=west] (l) at (a.east) {\texttt{pr.i1}};
\node[anch] (a) at (pr.o1) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{pr.o1}};
\node[anch] (a) at (pr.o2) {}; \node[label, anchor=east] (l) at (a.west) {\texttt{pr.o2}};
\node[anch] (a) at (fpr.f1) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fpr.f1}};
\node[anch] (a) at (fpr.f2) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fpr.f2}};
\node[anch] (a) at (fpr.f3) {}; \node[label, anchor=west, rotate=90] (l) at (a.north) {\texttt{fpr.f3}};
\node[anch] (a) at (fpr.f1i) {}; \node[label, anchor=west, rotate=-45] (l) at (a.north) {\texttt{fpr.f1i}};
\node[anch] (a) at (fpr.f2i) {}; \node[label, anchor=west, rotate=-45] (l) at (a.north) {\texttt{fpr.f2i}};
\node[anch] (a) at (fpr.f3i) {}; \node[label, anchor=west, rotate=-45] (l) at (a.north) {\texttt{fpr.f3i}};
\end{tikzpicture}
\end{figure}

\subsubsection{Parallel communication processes}

Parallel communication processes infer replication and specific interconnection between processes. They are mainly rearranging the data contained by vectors of signals and/or signals of vectors.

\newpage
\appendix
\section{PGF nodes} \label{appendix_shapes}

\end{document}